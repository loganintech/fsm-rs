use std::any::Any;
use std::cell::RefCell;
use std::collections::HashMap;
use std::rc::Rc;
use protobuf::EnumOrUnknown;
use crate::proto::button::*;
use crate::fsm::*;
use crate::proto;
use crate::action_db::DB as ActionDB;
use crate::state_db::DB as StateDB;


// region: Theoretically generated by protogen

impl StateEnum for LEDState {}

impl EventEnum for ButtonEvent {}

impl DBObj for LED {}

impl DBObj for Button {}

impl FSMState for LED {
    type State = LEDState;
    type Action = Button;

    fn get_state(&self) -> Self::State {
        self.state()
    }
}


impl FSMAction for Button {
    type Event = ButtonEvent;

    fn get_event(&self) -> Self::Event {
        self.event()
    }
}


pub struct LEDController {
    // Pretend DB Connection
    led_db: Rc<RefCell<StateDB<LED>>>,
    action_db: Rc<RefCell<ActionDB<Button>>>,
}

impl ActionGetter<LED> for ButtonController {
    fn unroll(&mut self, state: &LED) -> Vec<Button> {
        if let Some(action) = self.action_db.borrow_mut().pop() {
            return vec![action.clone()];
        };
        vec![]
    }
}

impl FSMController<LED> for LEDController {
    fn save_func(&mut self, obj: &LED, to_delete: Option<Button>, to_add: Option<&Button>) {
        self.led_db.borrow_mut().save(obj.clone());
        if let Some(to_add) = to_add {
            self.action_db.borrow_mut().save(to_add.clone());
        }
    }

    fn get(&self) -> Option<LED> {
        self.led_db.borrow().pop().clone()
    }
}

pub struct ButtonController {
    // Pretend DB Connection
    led_db: Rc<RefCell<StateDB<LED>>>,
    action_db: Rc<RefCell<ActionDB<Button>>>,
}

pub fn led_fsm_wrapper(led_db: Rc<RefCell<StateDB<LED>>>, action_db: Rc<RefCell<ActionDB<Button>>>) -> FSM<LED, LEDController, ButtonController> {
    let paths = [
        Path {
            source: LEDState::LED_STATE_ON,
            destination: LEDState::LED_STATE_OFF,
            event: ButtonEvent::BUTTON_EVENT_PRESSED,
        },
        Path {
            source: LEDState::LED_STATE_OFF,
            destination: LEDState::LED_STATE_ON,
            event: ButtonEvent::BUTTON_EVENT_PRESSED,
        },
    ];

    let mut routes: Routes<LED> = HashMap::new();
    routes.insert(LEDState::LED_STATE_ON, |state: &mut LED, action: &Button| -> Option<Button> {
        println!("On Handler");
        state.state = LEDState::LED_STATE_OFF.into();
        Some(Button {
            event: ButtonEvent::BUTTON_EVENT_PRESSED.into(),
            special_fields: Default::default(),
        })
    });
    routes.insert(LEDState::LED_STATE_OFF, |state: &mut LED, action: &Button| -> Option<Button>  {
        println!("Off Handler");
        state.state = LEDState::LED_STATE_ON.into();
        Some(Button {
            event: ButtonEvent::BUTTON_EVENT_PRESSED.into(),
            special_fields: Default::default(),
        })
    });




    FSM::new(LEDController {
        led_db: led_db.clone(),
        action_db: action_db.clone(),
    }, ButtonController {
        led_db: led_db.clone(),
        action_db: action_db.clone(),
    }, paths.into(), routes)
}

